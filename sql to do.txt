NOT BETWEEN
character functions
how to use distinct aggregate funcs: select aggr_func(distinct column) from table where condition;
primary key (col1, col2): composite key. col1 and col2 represent each row uniquely.
candidate keys: columns with unique not null constraint. if multiple columns have these both constraint, then they
                can be used as composite keys in the future.

what happens when UNION with different schema as in diff attr names but same datatype and logical coherence?
how to rename schema temporarily?
for all set operations:
SELECT column1 AS a, column2 AS b FROM table1
UNION ALL
SELECT columnA AS a, columnB AS b FROM table2;

db notes from mid 1



IN: checks if a tuple's attribute's value is equal to one of the value in the list of values
    generated by the subquery or in a direct list (eg: IN ('list_item1', 'list_item2', ..., 'list_itemN'); )

> ALL: compare each tuple's attribute's value to the whole list of attribute values returned by the subquery
       and select only those tuples from main query whose value is bigger than every value from the subquery.
       or could say, bigger than the max from that subquery. (higher than the max)

< ALL: compare each tuple's attribute's value to the whole list of attribute values returned by the subquery
       and select only those tuples from main query whose value is lesser than every value from the subquery.
       or could say, lesser than the min from that subquery. (lesser than the min)

> ANY: compare each tuple's attribute's value (from the main table) to the whole list of attribute values returned
       by the subquery and only select those tuples from the main table whose attribute value is higher than the
       lowest value in the subquery, or higher than the min.

< ANY: compare each tuple's attribute's value (from the main table) to the whole list of attribute values returned
       by the subquery and only select those tuples from the main table whose attribute value is lower than the
       highest value in the subquery, or lower than the max.

				'ANY' stays within the max and min range of subquery rows value
				while 'ALL' always goes out of it.

Correlated Subquery: when each row in main table is to be compared by every row in subquery table. its unlike multiple row operators
		     where main table's tuple is only compared to > or < than the whole list.
		     outer table used inside subquery to make it correlated subquery


EXISTS/NOT EXISTS: checks whether for this tuple in the main table, do any tuples exist in the subquery table/do the subquery form any tuples or table?
                   returns true or false.
				use NOT EXIST in a negative data question


DEFERRING: assume PK FK relation between two tables. A record is entered into the FK table for a PK value that doesnt exist yet. We can defer
	   the constraint check for foreign key violation until that value of PK is entered into the PK table.
	   CONSTRAINT fk_customer FOREIGN KEY (CustomerID)
           REFERENCES Customers(CustomerID) DEFERRABLE INITIALLY DEFERRED
	   initially immediate is the default

INDEX: CREATE INDEX index_name
       ON table_name (column1, column2, ...); single column or multi-column

CORRELATED SUBQUERIES: SELECT column1, column2, ...
		       FROM table1
		       WHERE condition
		       (SELECT column3
		       FROM table2
		       WHERE table2.columnX = table1.columnY);
SUBQUERY IN SELECT: SELECT first_name, last_name, (SELECT MAX(WEIGHT) FROM OBESE)
		    FROM employee;
SUBQUERY IN FROM(TEMP TABLES): SELECT t1.column1, t2.column2
			       FROM (SELECT column1 FROM table1 WHERE condition) AS temp1
			       JOIN (SELECT column2 FROM table2) AS temp2 ON temp1.column1 = temp2.column2;
SUBQUERY IN HAVING AND WHERE ARE SAME AND BOTH EZ
CROSS JOIN/CARTESIAN PRODUCT: SELECT *
	    FROM table1, table2;
INNER JOIN: SELECT *
	    FROM table1
	    INNER JOIN table2
	    ON table1.column_name = table2.column_name;
SELF JOIN: SELECT e1.column_name, e2.column_name
	   FROM table_name e1
	   INNER JOIN table_name e2
	   ON e1.related_column = e2.related_column;
LEFT OUTER: SELECT *
	    FROM table1
	    LEFT JOIN table2
	    ON table1.columnX = table2.columnY;
RIGHT OUTER: SELECT *
	     FROM table1
	     RIGHT JOIN table2
	     ON table1.columnX = table2.columnY;
FULL OUTER: SELECT *
	    FROM table1
 	    FULL JOIN table2
	    ON table1.columnX = table2.columnY;
NEGATIVE DATA: use !=, NOT, NOT IN, NOT EXISTS (last two for subqueries)
		-- Find all employees who have not placed an order
	       SELECT *
	       FROM Employees
               WHERE NOT EXISTS (SELECT * FROM Orders WHERE Orders.employee_id = Employees.employee_id); used it like corr subq

					OR
		-- Find all customers who have not made any purchases
		SELECT Customers.customer_id, Customers.customer_name
		FROM Customers
		LEFT JOIN Orders ON Customers.customer_id = Orders.customer_id
		WHERE Orders.order_id IS NULL;
