NOT BETWEEN
character functions
how to use distinct aggregate funcs: select aggr_func(distinct column) from table where condition;
primary key (col1, col2): composite key. col1 and col2 represent each row uniquely.
candidate keys: columns with unique not null constraint. if multiple columns have these both constraint, then they
                can be used as composite keys in the future.

what happens when UNION with different schema as in diff attr names but same datatype and logical coherence?
how to rename schema temporarily?
for all set operations:
SELECT column1 AS a, column2 AS b FROM table1
UNION ALL
SELECT columnA AS a, columnB AS b FROM table2;

db notes from mid 1



IN: checks if a tuple's attribute's value is equal to one of the value in the list of values
    generated by the subquery or in a direct list (eg: IN ('list_item1', 'list_item2', ..., 'list_itemN'); )

> ALL: compare each tuple's attribute's value to the whole list of attribute values returned by the subquery
       and select only those tuples from main query whose value is bigger than every value from the subquery.
       or could say, bigger than the max from that subquery. (higher than the max)

< ALL: compare each tuple's attribute's value to the whole list of attribute values returned by the subquery
       and select only those tuples from main query whose value is lesser than every value from the subquery.
       or could say, lesser than the min from that subquery. (lesser than the min)

> ANY: compare each tuple's attribute's value (from the main table) to the whole list of attribute values returned
       by the subquery and only select those tuples from the main table whose attribute value is higher than the
       lowest value in the subquery, or higher than the min.

< ANY: compare each tuple's attribute's value (from the main table) to the whole list of attribute values returned
       by the subquery and only select those tuples from the main table whose attribute value is lower than the
       highest value in the subquery, or lower than the max.

				'ANY' stays within the max and min range of subquery rows value
				while 'ALL' always goes out of it.

Correlated Subquery: when each row in main table is to be compared by every row in subquery table. its unlike multiple row operators
		     where main table's tuple is only compared to > or < than the whole list.
		     outer table used inside subquery to make it correlated subquery


EXISTS/NOT EXISTS: checks whether for this tuple in the main table, do any tuples exist in the subquery table/do the subquery form any tuples or table?
                   returns true or false.
				use NOT EXIST in a negative data question


DEFERRING: assume PK FK relation between two tables. A record is entered into the FK table for a PK value that doesnt exist yet. We can defer
	   the constraint check for foreign key violation until that value of PK is entered into the PK table.
	   CONSTRAINT fk_customer FOREIGN KEY (CustomerID)
           REFERENCES Customers(CustomerID) DEFERRABLE INITIALLY DEFERRED
	   initially immediate is the default